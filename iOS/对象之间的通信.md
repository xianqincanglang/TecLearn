### 对象之间的通信：三种方式(代理、block、通知)
举个例子，现在有A和B两个对象，其中A对象包含B对象，A如果想让B干甚，A只需要给B一个消息[B xiaoxi]，而此时,如果B对象让A对象干什么事呢，肯定是希望给A一个消息[A xiaoxi]，但是B中没有A对象啊.<br/>
* 思路一:那我们能不能给B一个属性是A对象呢，让B也包含A？<br/>
显然不行，第一，B对象中的A对象不是 包含B对象的那个A对象，第二 ，你包含我 我包含你 很可能会造成循环引用，最后两个对象都释放不了，造成内存泄漏。
* 思路二：使用代理，A包含B对象，当创建B对象的时候，A就把自己设为B的代理，如果B给它的代理发消息，就能保证是包含它的那个A对象去接受消息了。同时，代理属性我们都是使用关键字weak,就是为了避免循环引用。
* 思路二的延伸:block和代理的使用是一样的，只不过相对简单，不用制定协议、写代理方法。同时效率更高。
而通知呢，更灵活，发一个通知，谁都能注册接收通知，然后做事情。
### block的使用
```
### 1.在传递的时候，对于基本数据类型的外部变量来说，系统默认传递的仅仅是值，
也就是说这个局部变量是不能修改的。如果想修改值，会使用__block来修饰这个变
量。这样一来，系统在传递的时候，传的就是外部变量的地址，这样我们就可以修改值
了。
__block int a = 10;//用__block修饰之后，系统会传递a的地址(&a)
    
_block = ^{
    a += 20;
    NSLog(@"a = %d",a);//有地址，当然就可以修改a的值了。此时a的值是30
};
### 2.对于对象类型，传递的是地址，同时默认对该对象进行了一次强引用。系统进行
了强引用，而他又对该对象的内存管理袖手旁观，也就是说，他只做了强引用，但是没
有做释放操作。这个时候就会造成内存泄漏。所以，我们在使用对象的时候，在MRC
下，都会使用__block修饰，在ARC下，使用__weak修饰，这样一来，系统在传递的时
候就不会对该对象进行强引用，避免了内存泄漏。
- (void)viewDidLoad {
  [super viewDidLoad];
   
    UIView *view = [[UIView alloc] init];
    
    __weak typeof(view)_view = view;//_view和view指向同一块内存，而
    _view是弱引用,view的retainCount还是1.
    
    _block = ^{
        //view.frame = CGRectMake(0, 0, 100, 100);//在block内部使
        用view对象，系统会对view强引用，此时会造成内存泄漏。
        _view.frame = CGRectMake(0, 0, 100, 100);
    };
    
 }
```
#### 三种方式怎么调用
在使用代理和block的时候，我们可能意识到了一个事情，就是通信的两个对象之间，一定是有关系的(A包含B  或者 B包含A)，不然怎么设置代理，怎么实现别的对象的block。所以，当两个需要通信的对象之间有包含关系的时候，考虑代理和block。比如，上面的A和B对象，如果B想让A干不止一件事情，就用代理。如果就是一件事情，没必要又制订协议，有些代理方法，太麻烦，此时可以考虑使用block。

有的时候，需要通信的两个对象之间没有关系，或者是一个对象要跟多个对象通信的时候，就要用到通知了。比如，旅游类app，如果在第一个界面改了城市名，那其他平行界面也要知道改了城市名，显示对应的数据，这个时候 就可以用通知。