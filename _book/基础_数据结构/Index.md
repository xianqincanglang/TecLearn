http://data.biancheng.net/view/vip_255.html

# 栈与队列
 1.只要确定了入栈顺序,即可确定出栈顺序?
  错误 有可能不是一次性入栈的,中间有出栈的情况.
 2.栈和队列都是操作受限的线形表,队列允许在其两端进行计算,而栈只能在栈顶方向操作.


# 数组
### 矩阵(特殊矩阵的)压缩存储
* 特殊矩阵:对称矩阵、上(下)三角矩阵、稀疏矩阵.
以上  种特殊矩阵的压缩存储，除了将数据元素存储起来，还要存储矩阵的行数值和列数值.
* 三种方式:三元组顺序表、行逻辑链接的顺序表、十字链表
* 


# 树
###(三)折半查找(二分查找)
* 思想:先排序,再二分查找.
* 判断一个树是否是折半查找树:
    折半查找判定树实际上是一棵二叉排序树，它的中序序列是一个有序序列。可以在树结点上依次填上相应的元素，符合折半查找规则的树即是所求。
* 规则:
  折半查找整个算法中，关于mid的取值向上/向下需要统一。
  如果待查找序列中节点总数是偶数，计算mid值的时候一定涉及向上/向下取值问题。
  ```
向下取整
    1).如果待查找序列中节点总数是偶数，且向下取整，那么mid作为排序树的根节点，它的左子树中节点总数一定比右子树中节点总数小1。
        例如，在结点1,2,3,4中查找， low=1，high=4 mid=2（下取整）。因此，根节点为2， 左子树结点有1，右子树结点共有3，4
    2).如果待查找序列中节点总数是2，且向下取整，mid一定是其中较小的那一个，剩下的的那一个节点变成mid的右子树

向上取整
    1).如果待查找序列中节点总数是偶数，且向上取整，那么mid作为排序树的根节点，它的左子树中节点总数一定比右子树中节点总数大1。
    2).如果待查找序列中节点总数是2，且向上取整，mid一定是其中较大的那一个，剩下的的那一个节点变成mid的左子树

应用:确定哪一个符合二分查找;
  ```
### 红黑树

### B-树

### B+树
应用:关系数据库中的索引

* 红黑树、B树和B+树的比较
```
I.红黑树

II.B树
如果在内存中,红黑树比B树更优,如果涉及到磁盘操作,B树更优.



III.B+树是在B树的基础上做改造,它的数据都是在叶子结点,同时叶子结点之间还加了指针形成链表.

为什么这么设计,想想应用场景:关系数据库中的索引

如果是选择多条数据的话，B树需要做局部的中序遍历，可能要跨层访问。
而 B+ 树由于所有数据都在叶子结点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。

IV.总结:
既然hash比B+树更快,为什么mySQL还用B+树呢?
这和业务场景有关。如果只选一个数据，那确实是 Hash 更快。但是数据库中经常会选择多条，这时候由于 B+ 树索引有序，并且又有链表相连，它的查询效率比 Hash 就快很多了。
而且数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次装入内存，B+ 树的设计可以允许数据分批加载，同时树的高度较低，提高查找效率。

```







学习一个技术,理解它背后的设计理念、原理和解决问题的方法,远远比技术本身是什么梗重要.


### 
无向图
无向图<V,E>,e为边数,0<=e<=n(n-1)/2 (n为顶点数)
总度数(D)等于边数(e)的两倍.D=2e

